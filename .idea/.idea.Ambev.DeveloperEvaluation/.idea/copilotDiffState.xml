<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/Ambev.DeveloperEvaluation.Domain/Entities/Product.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Ambev.DeveloperEvaluation.Domain/Entities/Product.cs" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="using Ambev.DeveloperEvaluation.Common.Security;&#10;using Ambev.DeveloperEvaluation.Common.Validation;&#10;using Ambev.DeveloperEvaluation.Domain.Common;&#10;using Ambev.DeveloperEvaluation.Domain.Validation;&#10;&#10;namespace Ambev.DeveloperEvaluation.Domain.Entities;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents a product in the system with inventory and pricing information.&#10;/// This entity follows domain-driven design principles and includes business rules validation.&#10;/// &lt;/summary&gt;&#10;public class Product : BaseEntity, IProduct&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gets the name of the product.&#10;    /// Must not be null or empty and should be unique within the system.&#10;    /// &lt;/summary&gt;&#10;    public string Name { get; set; } = string.Empty;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the price of the product.&#10;    /// Must be greater than zero for active products.&#10;    /// &lt;/summary&gt;&#10;    public decimal Price { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the description of the product.&#10;    /// Provides detailed information about the product features and specifications.&#10;    /// &lt;/summary&gt;&#10;    public string Description { get; set; } = string.Empty;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the category of the product.&#10;    /// Used for product classification and filtering.&#10;    /// &lt;/summary&gt;&#10;    public string Category { get; set; } = string.Empty;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the image URL of the product.&#10;    /// Points to the product's main display image.&#10;    /// &lt;/summary&gt;&#10;    public string Image { get; set; } = string.Empty;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the current stock quantity of the product.&#10;    /// Must not be negative.&#10;    /// &lt;/summary&gt;&#10;    public int StockQuantity { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the minimum stock level for the product.&#10;    /// Used for automatic reorder alerts.&#10;    /// &lt;/summary&gt;&#10;    public int MinStockLevel { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the active status of the product.&#10;    /// Indicates whether the product can be sold.&#10;    /// &lt;/summary&gt;&#10;    public bool IsActive { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the date and time when the product was created.&#10;    /// &lt;/summary&gt;&#10;    public DateTime CreatedAt { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the date and time of the last update to the product information.&#10;    /// &lt;/summary&gt;&#10;    public DateTime? UpdatedAt { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the unique identifier of the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The product's ID as a string.&lt;/returns&gt;&#10;    string IProduct.Id =&gt; Id.ToString();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the name of the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The product name.&lt;/returns&gt;&#10;    string IProduct.Name =&gt; Name;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the price of the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The product price.&lt;/returns&gt;&#10;    decimal IProduct.Price =&gt; Price;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the description of the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The product description.&lt;/returns&gt;&#10;    string IProduct.Description =&gt; Description;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the category of the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The product category.&lt;/returns&gt;&#10;    string IProduct.Category =&gt; Category;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the image URL of the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The product image URL.&lt;/returns&gt;&#10;    string IProduct.Image =&gt; Image;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the stock quantity of the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The product stock quantity.&lt;/returns&gt;&#10;    int IProduct.StockQuantity =&gt; StockQuantity;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the minimum stock level for the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The minimum stock level.&lt;/returns&gt;&#10;    int IProduct.MinStockLevel =&gt; MinStockLevel;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the active status of the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;True if the product is active; otherwise, false.&lt;/returns&gt;&#10;    bool IProduct.IsActive =&gt; IsActive;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the creation date of the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The product creation date.&lt;/returns&gt;&#10;    DateTime IProduct.CreatedAt =&gt; CreatedAt;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the Product class.&#10;    /// &lt;/summary&gt;&#10;    public Product()&#10;    {&#10;        CreatedAt = DateTime.UtcNow;&#10;        IsActive = true;&#10;        MinStockLevel = 10;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a new product with the specified information.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;name&quot;&gt;The product name.&lt;/param&gt;&#10;    /// &lt;param name=&quot;price&quot;&gt;The product price.&lt;/param&gt;&#10;    /// &lt;param name=&quot;description&quot;&gt;The product description.&lt;/param&gt;&#10;    /// &lt;param name=&quot;category&quot;&gt;The product category.&lt;/param&gt;&#10;    /// &lt;param name=&quot;stockQuantity&quot;&gt;The initial stock quantity.&lt;/param&gt;&#10;    /// &lt;param name=&quot;minStockLevel&quot;&gt;The minimum stock level.&lt;/param&gt;&#10;    /// &lt;param name=&quot;image&quot;&gt;The product image URL.&lt;/param&gt;&#10;    /// &lt;returns&gt;A new Product instance.&lt;/returns&gt;&#10;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when required parameters are null, empty, or invalid.&lt;/exception&gt;&#10;    public static Product Create(string name, decimal price, string description, string category, &#10;        int stockQuantity = 0, int minStockLevel = 10, string? image = null)&#10;    {&#10;        if (string.IsNullOrWhiteSpace(name))&#10;            throw new ArgumentException(&quot;Product name cannot be null or empty.&quot;, nameof(name));&#10;&#10;        if (price &lt;= 0)&#10;            throw new ArgumentException(&quot;Product price must be greater than zero.&quot;, nameof(price));&#10;&#10;        if (string.IsNullOrWhiteSpace(category))&#10;            throw new ArgumentException(&quot;Product category cannot be null or empty.&quot;, nameof(category));&#10;&#10;        if (stockQuantity &lt; 0)&#10;            throw new ArgumentException(&quot;Stock quantity cannot be negative.&quot;, nameof(stockQuantity));&#10;&#10;        if (minStockLevel &lt; 0)&#10;            throw new ArgumentException(&quot;Minimum stock level cannot be negative.&quot;, nameof(minStockLevel));&#10;&#10;        return new Product&#10;        {&#10;            Name = name.Trim(),&#10;            Price = price,&#10;            Description = description?.Trim() ?? string.Empty,&#10;            Category = category.Trim(),&#10;            StockQuantity = stockQuantity,&#10;            MinStockLevel = minStockLevel,&#10;            Image = image?.Trim() ?? string.Empty&#10;        };&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Activates the product.&#10;    /// Changes the product's status to Active.&#10;    /// &lt;/summary&gt;&#10;    public void Activate()&#10;    {&#10;        IsActive = true;&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Deactivates the product.&#10;    /// Changes the product's status to Inactive.&#10;    /// &lt;/summary&gt;&#10;    public void Deactivate()&#10;    {&#10;        IsActive = false;&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the product price.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;newPrice&quot;&gt;The new price for the product.&lt;/param&gt;&#10;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when the new price is not greater than zero.&lt;/exception&gt;&#10;    public void UpdatePrice(decimal newPrice)&#10;    {&#10;        if (newPrice &lt;= 0)&#10;            throw new ArgumentException(&quot;Product price must be greater than zero.&quot;, nameof(newPrice));&#10;&#10;        Price = newPrice;&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the product information.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;name&quot;&gt;The new product name.&lt;/param&gt;&#10;    /// &lt;param name=&quot;description&quot;&gt;The new product description.&lt;/param&gt;&#10;    /// &lt;param name=&quot;category&quot;&gt;The new product category.&lt;/param&gt;&#10;    /// &lt;param name=&quot;image&quot;&gt;The new product image URL.&lt;/param&gt;&#10;    public void UpdateInfo(string? name = null, string? description = null, string? category = null, string? image = null)&#10;    {&#10;        if (!string.IsNullOrWhiteSpace(name))&#10;            Name = name.Trim();&#10;&#10;        if (description != null)&#10;            Description = description.Trim();&#10;&#10;        if (!string.IsNullOrWhiteSpace(category))&#10;            Category = category.Trim();&#10;&#10;        if (image != null)&#10;            Image = image.Trim();&#10;&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Adds stock to the product inventory.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;quantity&quot;&gt;The quantity to add to stock.&lt;/param&gt;&#10;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when quantity is not positive.&lt;/exception&gt;&#10;    public void AddStock(int quantity)&#10;    {&#10;        if (quantity &lt;= 0)&#10;            throw new ArgumentException(&quot;Quantity to add must be positive.&quot;, nameof(quantity));&#10;&#10;        StockQuantity += quantity;&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Removes stock from the product inventory.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;quantity&quot;&gt;The quantity to remove from stock.&lt;/param&gt;&#10;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when quantity is not positive or exceeds available stock.&lt;/exception&gt;&#10;    public void RemoveStock(int quantity)&#10;    {&#10;        if (quantity &lt;= 0)&#10;            throw new ArgumentException(&quot;Quantity to remove must be positive.&quot;, nameof(quantity));&#10;&#10;        if (quantity &gt; StockQuantity)&#10;            throw new ArgumentException(&quot;Cannot remove more stock than available.&quot;, nameof(quantity));&#10;&#10;        StockQuantity -= quantity;&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the minimum stock level for the product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;minLevel&quot;&gt;The new minimum stock level.&lt;/param&gt;&#10;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when minimum level is negative.&lt;/exception&gt;&#10;    public void UpdateMinStockLevel(int minLevel)&#10;    {&#10;        if (minLevel &lt; 0)&#10;            throw new ArgumentException(&quot;Minimum stock level cannot be negative.&quot;, nameof(minLevel));&#10;&#10;        MinStockLevel = minLevel;&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Checks if the product stock is below the minimum level.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;True if stock is below minimum level; otherwise, false.&lt;/returns&gt;&#10;    public bool IsLowStock()&#10;    {&#10;        return StockQuantity &lt;= MinStockLevel;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Checks if the product is out of stock.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;True if stock quantity is zero; otherwise, false.&lt;/returns&gt;&#10;    public bool IsOutOfStock()&#10;    {&#10;        return StockQuantity == 0;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Checks if the product is available for sale.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;True if product is active and has stock; otherwise, false.&lt;/returns&gt;&#10;    public bool IsAvailableForSale()&#10;    {&#10;        return IsActive &amp;&amp; !IsOutOfStock();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Performs validation of the product entity using the ProductValidator rules.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;&#10;    /// A &lt;see cref=&quot;ValidationResultDetail&quot;/&gt; containing:&#10;    /// - IsValid: Indicates whether all validation rules passed&#10;    /// - Errors: Collection of validation errors if any rules failed&#10;    /// &lt;/returns&gt;&#10;    public ValidationResultDetail Validate()&#10;    {&#10;        var validator = new ProductValidator();&#10;        var result = validator.Validate(this);&#10;        return new ValidationResultDetail&#10;        {&#10;            IsValid = result.IsValid,&#10;            Errors = result.Errors.Select(o =&gt; (ValidationErrorDetail)o)&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Ambev.DeveloperEvaluation.Domain/Entities/Sale.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Ambev.DeveloperEvaluation.Domain/Entities/Sale.cs" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="using Ambev.DeveloperEvaluation.Common.Security;&#10;using Ambev.DeveloperEvaluation.Common.Validation;&#10;using Ambev.DeveloperEvaluation.Domain.Common;&#10;using Ambev.DeveloperEvaluation.Domain.Validation;&#10;&#10;namespace Ambev.DeveloperEvaluation.Domain.Entities;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents a sale transaction in the system with customer, branch, and items information.&#10;/// This entity follows domain-driven design principles and includes comprehensive business rules validation.&#10;/// Manages the complete sale lifecycle including item management, discount calculation, and cancellation.&#10;/// &lt;/summary&gt;&#10;public class Sale : BaseEntity, ISale&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gets the sale number for identification and tracking purposes.&#10;    /// Automatically generated with a unique format when not provided.&#10;    /// &lt;/summary&gt;&#10;    public string SaleNumber { get; set; } = string.Empty;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the date when the sale was made.&#10;    /// Used for reporting and business analytics.&#10;    /// &lt;/summary&gt;&#10;    public DateTime SaleDate { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the customer associated with this sale.&#10;    /// Contains customer information for the transaction.&#10;    /// &lt;/summary&gt;&#10;    public Customer Customer { get; set; } = null!;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the branch where the sale was made.&#10;    /// Identifies the location of the transaction.&#10;    /// &lt;/summary&gt;&#10;    public Branch Branch { get; set; } = null!;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the collection of items included in the sale.&#10;    /// Each item represents a product with quantity, price, and discount information.&#10;    /// &lt;/summary&gt;&#10;    public List&lt;SaleItem&gt; Items { get; set; } = new();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the total amount for the sale after all discounts.&#10;    /// Automatically calculated from active (non-cancelled) items.&#10;    /// &lt;/summary&gt;&#10;    public decimal TotalAmount { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the cancellation status of the sale.&#10;    /// When cancelled, the entire sale is void and excluded from revenue calculations.&#10;    /// &lt;/summary&gt;&#10;    public bool IsCancelled { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the date and time when the sale was created.&#10;    /// &lt;/summary&gt;&#10;    public DateTime CreatedAt { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the date and time of the last update to the sale.&#10;    /// &lt;/summary&gt;&#10;    public DateTime? UpdatedAt { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the unique identifier of the sale.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The sale's ID as a string.&lt;/returns&gt;&#10;    string ISale.Id =&gt; Id.ToString();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the sale number.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The sale number.&lt;/returns&gt;&#10;    string ISale.SaleNumber =&gt; SaleNumber;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the date when the sale was made.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The sale date.&lt;/returns&gt;&#10;    DateTime ISale.SaleDate =&gt; SaleDate;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the customer data.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The customer information.&lt;/returns&gt;&#10;    ICustomer ISale.Customer =&gt; Customer;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the data of the branch where the sale was made.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The branch information.&lt;/returns&gt;&#10;    IBranch ISale.Branch =&gt; Branch;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the list of items included in the sale.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A readonly collection of sale items.&lt;/returns&gt;&#10;    IReadOnlyCollection&lt;ISaleItem&gt; ISale.Items =&gt; Items.Cast&lt;ISaleItem&gt;().ToList().AsReadOnly();&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the total amount for the sale.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The total sale amount.&lt;/returns&gt;&#10;    decimal ISale.TotalAmount =&gt; TotalAmount;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the cancellation status of the sale.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;True if the sale is cancelled; otherwise, false.&lt;/returns&gt;&#10;    bool ISale.IsCancelled =&gt; IsCancelled;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the date when the sale was created.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The sale creation date.&lt;/returns&gt;&#10;    DateTime ISale.CreatedAt =&gt; CreatedAt;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the date of the last update to the sale.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The last update date, if any.&lt;/returns&gt;&#10;    DateTime? ISale.UpdatedAt =&gt; UpdatedAt;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the Sale class.&#10;    /// &lt;/summary&gt;&#10;    public Sale()&#10;    {&#10;        Id = Guid.NewGuid(); // Ensure Sale has a valid ID when created&#10;        CreatedAt = DateTime.UtcNow;&#10;        SaleDate = DateTime.UtcNow;&#10;        Items = new List&lt;SaleItem&gt;();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a new sale with the specified information.&#10;    /// Automatically generates a sale number if not provided.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;customer&quot;&gt;The customer making the purchase.&lt;/param&gt;&#10;    /// &lt;param name=&quot;branch&quot;&gt;The branch where the sale is made.&lt;/param&gt;&#10;    /// &lt;param name=&quot;saleNumber&quot;&gt;Optional sale number (auto-generated if null).&lt;/param&gt;&#10;    /// &lt;param name=&quot;saleDate&quot;&gt;Optional sale date (current date if null).&lt;/param&gt;&#10;    /// &lt;returns&gt;A new Sale instance.&lt;/returns&gt;&#10;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when required parameters are null.&lt;/exception&gt;&#10;    public static Sale Create(Customer customer, Branch branch, string? saleNumber = null, DateTime? saleDate = null)&#10;    {&#10;        if (customer == null)&#10;            throw new ArgumentException(&quot;Customer cannot be null.&quot;, nameof(customer));&#10;&#10;        if (branch == null)&#10;            throw new ArgumentException(&quot;Branch cannot be null.&quot;, nameof(branch));&#10;&#10;        if (!customer.IsActive)&#10;            throw new InvalidOperationException(&quot;Cannot create sale for inactive customer.&quot;);&#10;&#10;        if (!branch.IsActive)&#10;            throw new InvalidOperationException(&quot;Cannot create sale for inactive branch.&quot;);&#10;&#10;        return new Sale&#10;        {&#10;            Customer = customer,&#10;            Branch = branch,&#10;            SaleNumber = saleNumber ?? GenerateSaleNumber(),&#10;            SaleDate = saleDate ?? DateTime.UtcNow&#10;        };&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Adds an item to the sale with automatic discount calculation.&#10;    /// Validates business rules including maximum quantity per product.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;product&quot;&gt;The product to add.&lt;/param&gt;&#10;    /// &lt;param name=&quot;quantity&quot;&gt;The quantity to add.&lt;/param&gt;&#10;    /// &lt;param name=&quot;unitPrice&quot;&gt;Optional unit price (uses product price if null).&lt;/param&gt;&#10;    /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when sale is cancelled or business rules are violated.&lt;/exception&gt;&#10;    public void AddItem(Product product, int quantity, decimal? unitPrice = null)&#10;    {&#10;        if (IsCancelled)&#10;            throw new InvalidOperationException(&quot;Cannot add items to a cancelled sale.&quot;);&#10;&#10;        if (product == null)&#10;            throw new ArgumentException(&quot;Product cannot be null.&quot;, nameof(product));&#10;&#10;        if (!product.IsAvailableForSale())&#10;            throw new InvalidOperationException(&quot;Product is not available for sale.&quot;);&#10;&#10;        // Check if adding this quantity would exceed the 20-unit limit for this product&#10;        var existingQuantity = Items&#10;            .Where(i =&gt; !i.IsCancelled &amp;&amp; i.Product.Id == product.Id)&#10;            .Sum(i =&gt; i.Quantity);&#10;&#10;        if (existingQuantity + quantity &gt; 20)&#10;            throw new InvalidOperationException(&quot;Cannot sell more than 20 units of the same product in a single sale.&quot;);&#10;&#10;        var saleItem = SaleItem.Create(Id, product, quantity, unitPrice);&#10;        Items.Add(saleItem);&#10;        &#10;        RecalculateTotal();&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Removes an item from the sale by cancelling it.&#10;    /// Recalculates the total amount after removal.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;itemId&quot;&gt;The ID of the item to remove.&lt;/param&gt;&#10;    /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when sale is cancelled or item not found.&lt;/exception&gt;&#10;    public void RemoveItem(Guid itemId)&#10;    {&#10;        if (IsCancelled)&#10;            throw new InvalidOperationException(&quot;Cannot remove items from a cancelled sale.&quot;);&#10;&#10;        var item = Items.FirstOrDefault(i =&gt; i.Id == itemId);&#10;        if (item == null)&#10;            throw new ArgumentException(&quot;Item not found in sale.&quot;, nameof(itemId));&#10;&#10;        item.Cancel();&#10;        RecalculateTotal();&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the quantity of an existing item in the sale.&#10;    /// Validates business rules and recalculates totals.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;itemId&quot;&gt;The ID of the item to update.&lt;/param&gt;&#10;    /// &lt;param name=&quot;newQuantity&quot;&gt;The new quantity for the item.&lt;/param&gt;&#10;    /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when sale is cancelled, item not found, or business rules violated.&lt;/exception&gt;&#10;    public void UpdateItemQuantity(Guid itemId, int newQuantity)&#10;    {&#10;        if (IsCancelled)&#10;            throw new InvalidOperationException(&quot;Cannot update items in a cancelled sale.&quot;);&#10;&#10;        var item = Items.FirstOrDefault(i =&gt; i.Id == itemId);&#10;        if (item == null)&#10;            throw new ArgumentException(&quot;Item not found in sale.&quot;, nameof(itemId));&#10;&#10;        // Check if updating this quantity would exceed the 20-unit limit for this product&#10;        var otherItemsQuantity = Items&#10;            .Where(i =&gt; !i.IsCancelled &amp;&amp; i.Product.Id == item.Product.Id &amp;&amp; i.Id != itemId)&#10;            .Sum(i =&gt; i.Quantity);&#10;&#10;        if (otherItemsQuantity + newQuantity &gt; 20)&#10;            throw new InvalidOperationException(&quot;Cannot sell more than 20 units of the same product in a single sale.&quot;);&#10;&#10;        item.UpdateQuantity(newQuantity);&#10;        RecalculateTotal();&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Cancels the entire sale.&#10;    /// Sets the sale as cancelled and zeros the total amount.&#10;    /// &lt;/summary&gt;&#10;    public void Cancel()&#10;    {&#10;        if (IsCancelled)&#10;            return;&#10;&#10;        IsCancelled = true;&#10;        TotalAmount = 0;&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Reactivates a cancelled sale.&#10;    /// Recalculates the total amount from active items.&#10;    /// &lt;/summary&gt;&#10;    public void Reactivate()&#10;    {&#10;        if (!IsCancelled)&#10;            return;&#10;&#10;        IsCancelled = false;&#10;        RecalculateTotal();&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the total discount amount applied to the sale.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The total discount amount across all items.&lt;/returns&gt;&#10;    public decimal GetTotalDiscount()&#10;    {&#10;        if (IsCancelled)&#10;            return 0;&#10;&#10;        return Items&#10;            .Where(i =&gt; !i.IsCancelled)&#10;            .Sum(i =&gt; i.GetDiscountAmount());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the subtotal before discount application.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The subtotal before discounts.&lt;/returns&gt;&#10;    public decimal GetSubtotal()&#10;    {&#10;        if (IsCancelled)&#10;            return 0;&#10;&#10;        return Items&#10;            .Where(i =&gt; !i.IsCancelled)&#10;            .Sum(i =&gt; i.GetSubtotal());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the number of active (non-cancelled) items in the sale.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The count of active items.&lt;/returns&gt;&#10;    public int GetActiveItemCount()&#10;    {&#10;        return Items.Count(i =&gt; !i.IsCancelled);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Checks if the sale has any items.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;True if the sale has active items; otherwise, false.&lt;/returns&gt;&#10;    public bool HasItems()&#10;    {&#10;        return GetActiveItemCount() &gt; 0;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Recalculates the total amount from all active items.&#10;    /// &lt;/summary&gt;&#10;    private void RecalculateTotal()&#10;    {&#10;        if (IsCancelled)&#10;        {&#10;            TotalAmount = 0;&#10;            return;&#10;        }&#10;&#10;        TotalAmount = Items&#10;            .Where(i =&gt; !i.IsCancelled)&#10;            .Sum(i =&gt; i.TotalPrice);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Generates a unique sale number with timestamp and random component.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;A unique sale number.&lt;/returns&gt;&#10;    private static string GenerateSaleNumber()&#10;    {&#10;        var timestamp = DateTime.UtcNow.ToString(&quot;yyyyMMddHHmmss&quot;);&#10;        var random = new Random().Next(100, 999);&#10;        return $&quot;SALE-{timestamp}-{random}&quot;;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Performs comprehensive validation of the sale entity using the SaleValidator rules.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;&#10;    /// A &lt;see cref=&quot;ValidationResultDetail&quot;/&gt; containing:&#10;    /// - IsValid: Indicates whether all validation rules passed&#10;    /// - Errors: Collection of validation errors if any rules failed&#10;    /// &lt;/returns&gt;&#10;    public ValidationResultDetail Validate()&#10;    {&#10;        var validator = new SaleValidator();&#10;        var result = validator.Validate(this);&#10;        return new ValidationResultDetail&#10;        {&#10;            IsValid = result.IsValid,&#10;            Errors = result.Errors.Select(o =&gt; (ValidationErrorDetail)o)&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Ambev.DeveloperEvaluation.Domain/Entities/SaleItem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Ambev.DeveloperEvaluation.Domain/Entities/SaleItem.cs" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="using Ambev.DeveloperEvaluation.Common.Security;&#10;using Ambev.DeveloperEvaluation.Common.Validation;&#10;using Ambev.DeveloperEvaluation.Domain.Common;&#10;using Ambev.DeveloperEvaluation.Domain.Validation;&#10;&#10;namespace Ambev.DeveloperEvaluation.Domain.Entities;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an item within a sale transaction in the system.&#10;/// This entity follows domain-driven design principles and includes business rules validation.&#10;/// Implements automatic discount calculation based on quantity purchased.&#10;/// &lt;/summary&gt;&#10;public class SaleItem : BaseEntity, ISaleItem&#10;{&#10;    /// &lt;summary&gt;&#10;    /// Gets the unique identifier for the sale associated with this item.&#10;    /// &lt;/summary&gt;&#10;    public Guid SaleId { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the product associated with the sale item.&#10;    /// &lt;/summary&gt;&#10;    public Product Product { get; set; } = null!;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the quantity of the product sold in this item.&#10;    /// Must be between 1 and 20 (business rule for maximum quantity per product).&#10;    /// &lt;/summary&gt;&#10;    public int Quantity { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the discount percentage applied to this sale item.&#10;    /// Automatically calculated based on quantity: 4-9 items = 10%, 10-20 items = 20%.&#10;    /// &lt;/summary&gt;&#10;    public decimal DiscountPercent { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the price of the product at the time of sale.&#10;    /// Captures the product price to maintain historical accuracy.&#10;    /// &lt;/summary&gt;&#10;    public decimal UnitPrice { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the total price for this sale item after discount application.&#10;    /// Calculated as (Quantity * UnitPrice) - discount.&#10;    /// &lt;/summary&gt;&#10;    public decimal TotalPrice { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the cancellation status of the sale item.&#10;    /// When cancelled, the item is excluded from sale totals.&#10;    /// &lt;/summary&gt;&#10;    public bool IsCancelled { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the date and time when the sale item was created.&#10;    /// &lt;/summary&gt;&#10;    public DateTime CreatedAt { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the date and time of the last update to the sale item.&#10;    /// &lt;/summary&gt;&#10;    public DateTime? UpdatedAt { get; set; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the unique identifier of the sale item.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The sale item ID.&lt;/returns&gt;&#10;    Guid ISaleItem.Id =&gt; Id;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the unique identifier for the sale associated with this item.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The Sale ID.&lt;/returns&gt;&#10;    Guid ISaleItem.SaleId =&gt; SaleId;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the product associated with the sale item.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The product information.&lt;/returns&gt;&#10;    IProduct ISaleItem.Product =&gt; Product;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the quantity of the product sold in this item.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The quantity sold.&lt;/returns&gt;&#10;    int ISaleItem.Quantity =&gt; Quantity;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the discount percentage applied to this sale item.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The discount percentage (0-100).&lt;/returns&gt;&#10;    decimal ISaleItem.DiscountPercent =&gt; DiscountPercent;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the price of the product at the time of sale.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The unit price of the product.&lt;/returns&gt;&#10;    decimal ISaleItem.UnitPrice =&gt; UnitPrice;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the total price for this sale item after discount.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The total price for the sale item.&lt;/returns&gt;&#10;    decimal ISaleItem.TotalPrice =&gt; TotalPrice;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the cancellation status of the sale item.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;True if the item is cancelled; otherwise, false.&lt;/returns&gt;&#10;    bool ISaleItem.IsCancelled =&gt; IsCancelled;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the SaleItem class.&#10;    /// &lt;/summary&gt;&#10;    public SaleItem()&#10;    {&#10;        CreatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a new sale item with the specified information.&#10;    /// Automatically calculates discount and total price based on business rules.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;saleId&quot;&gt;The sale ID this item belongs to.&lt;/param&gt;&#10;    /// &lt;param name=&quot;product&quot;&gt;The product being sold.&lt;/param&gt;&#10;    /// &lt;param name=&quot;quantity&quot;&gt;The quantity being sold.&lt;/param&gt;&#10;    /// &lt;param name=&quot;unitPrice&quot;&gt;The unit price at time of sale.&lt;/param&gt;&#10;    /// &lt;returns&gt;A new SaleItem instance.&lt;/returns&gt;&#10;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when parameters are invalid.&lt;/exception&gt;&#10;    /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when business rules are violated.&lt;/exception&gt;&#10;    public static SaleItem Create(Guid saleId, Product product, int quantity, decimal? unitPrice = null)&#10;    {&#10;        if (saleId == Guid.Empty)&#10;            throw new ArgumentException(&quot;Sale ID cannot be empty.&quot;, nameof(saleId));&#10;&#10;        if (product == null)&#10;            throw new ArgumentException(&quot;Product cannot be null.&quot;, nameof(product));&#10;&#10;        if (quantity &lt;= 0)&#10;            throw new ArgumentException(&quot;Quantity must be greater than zero.&quot;, nameof(quantity));&#10;&#10;        if (quantity &gt; 20)&#10;            throw new InvalidOperationException(&quot;Cannot sell more than 20 units of the same product in a single sale.&quot;);&#10;&#10;        var finalUnitPrice = unitPrice ?? product.Price;&#10;        if (finalUnitPrice &lt;= 0)&#10;            throw new ArgumentException(&quot;Unit price must be greater than zero.&quot;, nameof(unitPrice));&#10;&#10;        var saleItem = new SaleItem&#10;        {&#10;            SaleId = saleId,&#10;            Product = product,&#10;            Quantity = quantity,&#10;            UnitPrice = finalUnitPrice&#10;        };&#10;&#10;        saleItem.CalculateDiscountAndTotal();&#10;        return saleItem;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Cancels the sale item.&#10;    /// Sets the item as cancelled and excludes it from calculations.&#10;    /// &lt;/summary&gt;&#10;    public void Cancel()&#10;    {&#10;        if (IsCancelled)&#10;            return;&#10;&#10;        IsCancelled = true;&#10;        TotalPrice = 0;&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Reactivates a cancelled sale item.&#10;    /// Recalculates the total price and discount.&#10;    /// &lt;/summary&gt;&#10;    public void Reactivate()&#10;    {&#10;        if (!IsCancelled)&#10;            return;&#10;&#10;        IsCancelled = false;&#10;        CalculateDiscountAndTotal();&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Updates the quantity and recalculates discount and total.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;newQuantity&quot;&gt;The new quantity for the item.&lt;/param&gt;&#10;    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;Thrown when quantity is invalid.&lt;/exception&gt;&#10;    /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown when business rules are violated or item is cancelled.&lt;/exception&gt;&#10;    public void UpdateQuantity(int newQuantity)&#10;    {&#10;        if (IsCancelled)&#10;            throw new InvalidOperationException(&quot;Cannot update quantity of a cancelled item.&quot;);&#10;&#10;        if (newQuantity &lt;= 0)&#10;            throw new ArgumentException(&quot;Quantity must be greater than zero.&quot;, nameof(newQuantity));&#10;&#10;        if (newQuantity &gt; 20)&#10;            throw new InvalidOperationException(&quot;Cannot sell more than 20 units of the same product in a single sale.&quot;);&#10;&#10;        Quantity = newQuantity;&#10;        CalculateDiscountAndTotal();&#10;        UpdatedAt = DateTime.UtcNow;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Calculates the discount percentage and total price based on business rules.&#10;    /// Business Rules:&#10;    /// - 4 to 9 items: 10% discount&#10;    /// - 10 to 20 items: 20% discount&#10;    /// - Less than 4 items: No discount&#10;    /// &lt;/summary&gt;&#10;    private void CalculateDiscountAndTotal()&#10;    {&#10;        if (IsCancelled)&#10;        {&#10;            TotalPrice = 0;&#10;            return;&#10;        }&#10;&#10;        // Calculate discount based on quantity&#10;        DiscountPercent = Quantity switch&#10;        {&#10;            &gt;= 10 and &lt;= 20 =&gt; 20m,&#10;            &gt;= 4 and &lt; 10 =&gt; 10m,&#10;            _ =&gt; 0m&#10;        };&#10;&#10;        var subtotal = Quantity * UnitPrice;&#10;        var discountAmount = subtotal * (DiscountPercent / 100m);&#10;        TotalPrice = Math.Round(subtotal - discountAmount, 2, MidpointRounding.AwayFromZero);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the discount amount in currency.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The discount amount applied to this item.&lt;/returns&gt;&#10;    public decimal GetDiscountAmount()&#10;    {&#10;        if (IsCancelled)&#10;            return 0;&#10;&#10;        var subtotal = Quantity * UnitPrice;&#10;        return Math.Round(subtotal * (DiscountPercent / 100m), 2, MidpointRounding.AwayFromZero);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the subtotal before discount application.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The subtotal before discount.&lt;/returns&gt;&#10;    public decimal GetSubtotal()&#10;    {&#10;        return IsCancelled ? 0 : Quantity * UnitPrice;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Performs validation of the sale item entity using the SaleItemValidator rules.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;&#10;    /// A &lt;see cref=&quot;ValidationResultDetail&quot;/&gt; containing:&#10;    /// - IsValid: Indicates whether all validation rules passed&#10;    /// - Errors: Collection of validation errors if any rules failed&#10;    /// &lt;/returns&gt;&#10;    public ValidationResultDetail Validate()&#10;    {&#10;        var validator = new SaleItemValidator();&#10;        var result = validator.Validate(this);&#10;        return new ValidationResultDetail&#10;        {&#10;            IsValid = result.IsValid,&#10;            Errors = result.Errors.Select(o =&gt; (ValidationErrorDetail)o)&#10;        };&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/Ambev.DeveloperEvaluation.Unit/Domain/Validation/BranchValidatorTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/Ambev.DeveloperEvaluation.Unit/Domain/Validation/BranchValidatorTests.cs" />
              <option name="updatedContent" value="using Ambev.DeveloperEvaluation.Domain.Validation;&#10;using Ambev.DeveloperEvaluation.Unit.Domain.Entities.TestData;&#10;using FluentValidation.TestHelper;&#10;using Xunit;&#10;&#10;namespace Ambev.DeveloperEvaluation.Unit.Domain.Validation;&#10;&#10;/// &lt;summary&gt;&#10;/// Contains unit tests for the BranchValidator class.&#10;/// Tests cover validation of all branch properties including name, address,&#10;/// manager, email, phone, and creation date requirements.&#10;/// &lt;/summary&gt;&#10;public class BranchValidatorTests&#10;{&#10;    private readonly BranchValidator _validator;&#10;&#10;    public BranchValidatorTests()&#10;    {&#10;        _validator = new BranchValidator();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation passes when all branch properties are valid.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Valid branch should pass all validation rules&quot;)]&#10;    public void Given_ValidBranch_When_Validated_Then_ShouldNotHaveErrors()&#10;    {&#10;        // Arrange&#10;        var branch = BranchTestData.GenerateValidBranch();&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(branch);&#10;&#10;        // Assert&#10;        result.ShouldNotHaveAnyValidationErrors();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when branch name is empty.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty branch name should fail validation&quot;)]&#10;    public void Given_EmptyBranchName_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var branch = BranchTestData.GenerateValidBranch();&#10;        branch.Name = string.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(branch);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(b =&gt; b.Name)&#10;            .WithErrorMessage(&quot;Branch name is required.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when branch name is too short.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Branch name too short should fail validation&quot;)]&#10;    public void Given_BranchNameTooShort_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var branch = BranchTestData.GenerateValidBranch();&#10;        branch.Name = &quot;A&quot;;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(branch);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(b =&gt; b.Name)&#10;            .WithErrorMessage(&quot;Branch name must be at least 2 characters long.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when branch name is too long.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Branch name too long should fail validation&quot;)]&#10;    public void Given_BranchNameTooLong_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var branch = BranchTestData.GenerateValidBranch();&#10;        branch.Name = new string('A', 101);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(branch);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(b =&gt; b.Name)&#10;            .WithErrorMessage(&quot;Branch name cannot be longer than 100 characters.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when branch address is empty.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty branch address should fail validation&quot;)]&#10;    public void Given_EmptyBranchAddress_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var branch = BranchTestData.GenerateValidBranch();&#10;        branch.Address = string.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(branch);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(b =&gt; b.Address)&#10;            .WithErrorMessage(&quot;Branch address is required.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when branch address is too short.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Branch address too short should fail validation&quot;)]&#10;    public void Given_BranchAddressTooShort_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var branch = BranchTestData.GenerateValidBranch();&#10;        branch.Address = &quot;123&quot;;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(branch);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(b =&gt; b.Address)&#10;            .WithErrorMessage(&quot;Branch address must be at least 10 characters long.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when branch manager is empty.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty branch manager should fail validation&quot;)]&#10;    public void Given_EmptyBranchManager_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var branch = BranchTestData.GenerateValidBranch();&#10;        branch.Manager = string.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(branch);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(b =&gt; b.Manager)&#10;            .WithErrorMessage(&quot;Branch manager name is required.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when branch has invalid email format.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Invalid email format should fail validation&quot;)]&#10;    public void Given_InvalidEmailFormat_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var branch = BranchTestData.GenerateValidBranch();&#10;        branch.Email = &quot;invalid-email&quot;;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(branch);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(b =&gt; b.Email);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation passes when email is empty (optional field).&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty email should pass validation&quot;)]&#10;    public void Given_EmptyEmail_When_Validated_Then_ShouldNotHaveError()&#10;    {&#10;        // Arrange&#10;        var branch = BranchTestData.GenerateValidBranch();&#10;        branch.Email = string.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(branch);&#10;&#10;        // Assert&#10;        result.ShouldNotHaveValidationErrorFor(b =&gt; b.Email);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when creation date is in the future.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Future creation date should fail validation&quot;)]&#10;    public void Given_FutureCreationDate_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var branch = BranchTestData.GenerateValidBranch();&#10;        branch.CreatedAt = DateTime.UtcNow.AddDays(1);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(branch);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(b =&gt; b.CreatedAt)&#10;            .WithErrorMessage(&quot;Branch creation date cannot be in the future.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/Ambev.DeveloperEvaluation.Unit/Domain/Validation/CustomerValidatorTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/Ambev.DeveloperEvaluation.Unit/Domain/Validation/CustomerValidatorTests.cs" />
              <option name="updatedContent" value="using Ambev.DeveloperEvaluation.Domain.Validation;&#10;using Ambev.DeveloperEvaluation.Unit.Domain.Entities.TestData;&#10;using FluentValidation.TestHelper;&#10;using Xunit;&#10;&#10;namespace Ambev.DeveloperEvaluation.Unit.Domain.Validation;&#10;&#10;/// &lt;summary&gt;&#10;/// Contains unit tests for the CustomerValidator class.&#10;/// Tests cover validation of all customer properties including name, email,&#10;/// phone, birth date, address, and creation date requirements.&#10;/// &lt;/summary&gt;&#10;public class CustomerValidatorTests&#10;{&#10;    private readonly CustomerValidator _validator;&#10;&#10;    public CustomerValidatorTests()&#10;    {&#10;        _validator = new CustomerValidator();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation passes when all customer properties are valid.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Valid customer should pass all validation rules&quot;)]&#10;    public void Given_ValidCustomer_When_Validated_Then_ShouldNotHaveErrors()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldNotHaveAnyValidationErrors();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when customer name is empty.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty customer name should fail validation&quot;)]&#10;    public void Given_EmptyCustomerName_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.Name = string.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(c =&gt; c.Name)&#10;            .WithErrorMessage(&quot;Customer name is required.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when customer name is too short.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Customer name too short should fail validation&quot;)]&#10;    public void Given_CustomerNameTooShort_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.Name = &quot;A&quot;;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(c =&gt; c.Name)&#10;            .WithErrorMessage(&quot;Customer name must be at least 2 characters long.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when customer name is too long.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Customer name too long should fail validation&quot;)]&#10;    public void Given_CustomerNameTooLong_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.Name = new string('A', 101);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(c =&gt; c.Name)&#10;            .WithErrorMessage(&quot;Customer name cannot be longer than 100 characters.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when customer email is empty.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty customer email should fail validation&quot;)]&#10;    public void Given_EmptyCustomerEmail_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.Email = string.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(c =&gt; c.Email);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when customer email has invalid format.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Invalid email format should fail validation&quot;)]&#10;    public void Given_InvalidEmailFormat_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.Email = &quot;invalid-email&quot;;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(c =&gt; c.Email);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when birth date is in the future.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Future birth date should fail validation&quot;)]&#10;    public void Given_FutureBirthDate_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.BirthDate = DateTime.Today.AddDays(1);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(c =&gt; c.BirthDate)&#10;            .WithErrorMessage(&quot;Birth date cannot be today or in the future.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when birth date is too far in the past.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Birth date too old should fail validation&quot;)]&#10;    public void Given_BirthDateTooOld_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.BirthDate = DateTime.Today.AddYears(-121);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(c =&gt; c.BirthDate)&#10;            .WithErrorMessage(&quot;Birth date cannot be more than 120 years ago.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation passes when birth date is null (optional field).&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Null birth date should pass validation&quot;)]&#10;    public void Given_NullBirthDate_When_Validated_Then_ShouldNotHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.BirthDate = null;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldNotHaveValidationErrorFor(c =&gt; c.BirthDate);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when address is too long.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Address too long should fail validation&quot;)]&#10;    public void Given_AddressTooLong_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.Address = new string('A', 201);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(c =&gt; c.Address)&#10;            .WithErrorMessage(&quot;Customer address cannot be longer than 200 characters.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation passes when address is empty (optional field).&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty address should pass validation&quot;)]&#10;    public void Given_EmptyAddress_When_Validated_Then_ShouldNotHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.Address = string.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldNotHaveValidationErrorFor(c =&gt; c.Address);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when creation date is in the future.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Future creation date should fail validation&quot;)]&#10;    public void Given_FutureCreationDate_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var customer = CustomerTestData.GenerateValidCustomer();&#10;        customer.CreatedAt = DateTime.UtcNow.AddDays(1);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(customer);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(c =&gt; c.CreatedAt)&#10;            .WithErrorMessage(&quot;Customer creation date cannot be in the future.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/Ambev.DeveloperEvaluation.Unit/Domain/Validation/ProductValidatorTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/Ambev.DeveloperEvaluation.Unit/Domain/Validation/ProductValidatorTests.cs" />
              <option name="updatedContent" value="using Ambev.DeveloperEvaluation.Domain.Validation;&#10;using Ambev.DeveloperEvaluation.Unit.Domain.Entities.TestData;&#10;using FluentValidation.TestHelper;&#10;using Xunit;&#10;&#10;namespace Ambev.DeveloperEvaluation.Unit.Domain.Validation;&#10;&#10;/// &lt;summary&gt;&#10;/// Contains unit tests for the ProductValidator class.&#10;/// Tests cover validation of all product properties including name, price,&#10;/// category, description, stock quantities, image, and creation date requirements.&#10;/// &lt;/summary&gt;&#10;public class ProductValidatorTests&#10;{&#10;    private readonly ProductValidator _validator;&#10;&#10;    public ProductValidatorTests()&#10;    {&#10;        _validator = new ProductValidator();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation passes when all product properties are valid.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Valid product should pass all validation rules&quot;)]&#10;    public void Given_ValidProduct_When_Validated_Then_ShouldNotHaveErrors()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldNotHaveAnyValidationErrors();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when product name is empty.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty product name should fail validation&quot;)]&#10;    public void Given_EmptyProductName_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Name = string.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.Name)&#10;            .WithErrorMessage(&quot;Product name is required.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when product name is too short.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Product name too short should fail validation&quot;)]&#10;    public void Given_ProductNameTooShort_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Name = &quot;A&quot;;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.Name)&#10;            .WithErrorMessage(&quot;Product name must be at least 2 characters long.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when product name is too long.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Product name too long should fail validation&quot;)]&#10;    public void Given_ProductNameTooLong_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Name = new string('A', 101);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.Name)&#10;            .WithErrorMessage(&quot;Product name cannot be longer than 100 characters.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when product price is zero.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Zero product price should fail validation&quot;)]&#10;    public void Given_ZeroProductPrice_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Price = 0m;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.Price)&#10;            .WithErrorMessage(&quot;Product price must be greater than zero.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when product price is negative.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Negative product price should fail validation&quot;)]&#10;    public void Given_NegativeProductPrice_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Price = -10.50m;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.Price)&#10;            .WithErrorMessage(&quot;Product price must be greater than zero.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when product price exceeds maximum limit.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Product price exceeding limit should fail validation&quot;)]&#10;    public void Given_ProductPriceExceedingLimit_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Price = 1000001m;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.Price)&#10;            .WithErrorMessage(&quot;Product price cannot exceed 1,000,000.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when product category is empty.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty product category should fail validation&quot;)]&#10;    public void Given_EmptyProductCategory_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Category = string.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.Category)&#10;            .WithErrorMessage(&quot;Product category is required.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when product category is too long.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Product category too long should fail validation&quot;)]&#10;    public void Given_ProductCategoryTooLong_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Category = new string('A', 51);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.Category)&#10;            .WithErrorMessage(&quot;Product category cannot be longer than 50 characters.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when description is too long.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Product description too long should fail validation&quot;)]&#10;    public void Given_ProductDescriptionTooLong_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Description = new string('A', 501);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.Description)&#10;            .WithErrorMessage(&quot;Product description cannot be longer than 500 characters.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation passes when description is empty (optional field).&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty description should pass validation&quot;)]&#10;    public void Given_EmptyDescription_When_Validated_Then_ShouldNotHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Description = string.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldNotHaveValidationErrorFor(p =&gt; p.Description);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when stock quantity is negative.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Negative stock quantity should fail validation&quot;)]&#10;    public void Given_NegativeStockQuantity_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.StockQuantity = -5;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.StockQuantity)&#10;            .WithErrorMessage(&quot;Stock quantity cannot be negative.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when minimum stock level is negative.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Negative minimum stock level should fail validation&quot;)]&#10;    public void Given_NegativeMinStockLevel_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.MinStockLevel = -3;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.MinStockLevel)&#10;            .WithErrorMessage(&quot;Minimum stock level cannot be negative.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when image URL is too long.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Image URL too long should fail validation&quot;)]&#10;    public void Given_ImageUrlTooLong_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.Image = new string('A', 301);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.Image)&#10;            .WithErrorMessage(&quot;Product image URL cannot be longer than 300 characters.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when creation date is in the future.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Future creation date should fail validation&quot;)]&#10;    public void Given_FutureCreationDate_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var product = ProductTestData.GenerateValidProduct();&#10;        product.CreatedAt = DateTime.UtcNow.AddDays(1);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(product);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(p =&gt; p.CreatedAt)&#10;            .WithErrorMessage(&quot;Product creation date cannot be in the future.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/Ambev.DeveloperEvaluation.Unit/Domain/Validation/SaleItemValidatorTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/Ambev.DeveloperEvaluation.Unit/Domain/Validation/SaleItemValidatorTests.cs" />
              <option name="updatedContent" value="using Ambev.DeveloperEvaluation.Domain.Validation;&#10;using Ambev.DeveloperEvaluation.Unit.Domain.Entities.TestData;&#10;using FluentValidation.TestHelper;&#10;using Xunit;&#10;&#10;namespace Ambev.DeveloperEvaluation.Unit.Domain.Validation;&#10;&#10;/// &lt;summary&gt;&#10;/// Contains unit tests for the SaleItemValidator class.&#10;/// Tests cover validation of all sale item properties including sale ID, product,&#10;/// quantity, unit price, discount percent, and business rule validations for discount calculations.&#10;/// &lt;/summary&gt;&#10;public class SaleItemValidatorTests&#10;{&#10;    private readonly SaleItemValidator _validator;&#10;&#10;    public SaleItemValidatorTests()&#10;    {&#10;        _validator = new SaleItemValidator();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation passes when all sale item properties are valid.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Valid sale item should pass all validation rules&quot;)]&#10;    public void Given_ValidSaleItem_When_Validated_Then_ShouldNotHaveErrors()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldNotHaveAnyValidationErrors();&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when sale ID is empty.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Empty sale ID should fail validation&quot;)]&#10;    public void Given_EmptySaleId_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.SaleId = Guid.Empty;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.SaleId)&#10;            .WithErrorMessage(&quot;Sale ID is required.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when product is null.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Null product should fail validation&quot;)]&#10;    public void Given_NullProduct_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.Product = null!;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.Product)&#10;            .WithErrorMessage(&quot;Product is required.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when quantity is zero.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Zero quantity should fail validation&quot;)]&#10;    public void Given_ZeroQuantity_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.Quantity = 0;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.Quantity)&#10;            .WithErrorMessage(&quot;Quantity must be greater than zero.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when quantity is negative.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Negative quantity should fail validation&quot;)]&#10;    public void Given_NegativeQuantity_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.Quantity = -5;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.Quantity)&#10;            .WithErrorMessage(&quot;Quantity must be greater than zero.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when quantity exceeds maximum limit (20).&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Quantity over 20 should fail validation&quot;)]&#10;    public void Given_QuantityOver20_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.Quantity = 21;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.Quantity)&#10;            .WithErrorMessage(&quot;Cannot sell more than 20 units of the same product in a single sale.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when unit price is zero.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Zero unit price should fail validation&quot;)]&#10;    public void Given_ZeroUnitPrice_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.UnitPrice = 0m;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.UnitPrice)&#10;            .WithErrorMessage(&quot;Unit price must be greater than zero.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when unit price is negative.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Negative unit price should fail validation&quot;)]&#10;    public void Given_NegativeUnitPrice_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.UnitPrice = -10.50m;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.UnitPrice)&#10;            .WithErrorMessage(&quot;Unit price must be greater than zero.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when unit price exceeds maximum limit.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Unit price exceeding limit should fail validation&quot;)]&#10;    public void Given_UnitPriceExceedingLimit_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.UnitPrice = 1000001m;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.UnitPrice)&#10;            .WithErrorMessage(&quot;Unit price cannot exceed 1,000,000.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when discount percent is negative.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Negative discount percent should fail validation&quot;)]&#10;    public void Given_NegativeDiscountPercent_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.DiscountPercent = -5m;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.DiscountPercent)&#10;            .WithErrorMessage(&quot;Discount percentage cannot be negative.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when discount percent exceeds 100.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Discount percent over 100 should fail validation&quot;)]&#10;    public void Given_DiscountPercentOver100_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.DiscountPercent = 105m;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.DiscountPercent)&#10;            .WithErrorMessage(&quot;Discount percentage cannot exceed 100%.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation passes when total price is zero for cancelled items.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Zero total price for cancelled item should pass validation&quot;)]&#10;    public void Given_CancelledItemWithZeroTotalPrice_When_Validated_Then_ShouldNotHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateCancelledSaleItem();&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldNotHaveValidationErrorFor(si =&gt; si.TotalPrice);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests that validation fails when creation date is in the future.&#10;    /// &lt;/summary&gt;&#10;    [Fact(DisplayName = &quot;Future creation date should fail validation&quot;)]&#10;    public void Given_FutureCreationDate_When_Validated_Then_ShouldHaveError()&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.CreatedAt = DateTime.UtcNow.AddDays(1);&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si.CreatedAt)&#10;            .WithErrorMessage(&quot;Sale item creation date cannot be in the future.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests business rule: discount should match quantity for 4-9 items (10% discount).&#10;    /// &lt;/summary&gt;&#10;    [Theory(DisplayName = &quot;Discount should match quantity for 4-9 items&quot;)]&#10;    [InlineData(4)]&#10;    [InlineData(6)]&#10;    [InlineData(9)]&#10;    public void Given_Quantity4To9WithWrongDiscount_When_Validated_Then_ShouldHaveError(int quantity)&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.Quantity = quantity;&#10;        saleItem.DiscountPercent = 20m; // Wrong discount (should be 10%)&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si)&#10;            .WithErrorMessage(&quot;Discount percentage does not match the quantity rules.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests business rule: discount should match quantity for 10-20 items (20% discount).&#10;    /// &lt;/summary&gt;&#10;    [Theory(DisplayName = &quot;Discount should match quantity for 10-20 items&quot;)]&#10;    [InlineData(10)]&#10;    [InlineData(15)]&#10;    [InlineData(20)]&#10;    public void Given_Quantity10To20WithWrongDiscount_When_Validated_Then_ShouldHaveError(int quantity)&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.Quantity = quantity;&#10;        saleItem.DiscountPercent = 10m; // Wrong discount (should be 20%)&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si)&#10;            .WithErrorMessage(&quot;Discount percentage does not match the quantity rules.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests business rule: discount should match quantity for 1-3 items (0% discount).&#10;    /// &lt;/summary&gt;&#10;    [Theory(DisplayName = &quot;Discount should match quantity for 1-3 items&quot;)]&#10;    [InlineData(1)]&#10;    [InlineData(2)]&#10;    [InlineData(3)]&#10;    public void Given_Quantity1To3WithWrongDiscount_When_Validated_Then_ShouldHaveError(int quantity)&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.Quantity = quantity;&#10;        saleItem.DiscountPercent = 10m; // Wrong discount (should be 0%)&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldHaveValidationErrorFor(si =&gt; si)&#10;            .WithErrorMessage(&quot;Discount percentage does not match the quantity rules.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Tests business rule: correct discount validation passes for different quantity ranges.&#10;    /// &lt;/summary&gt;&#10;    [Theory(DisplayName = &quot;Correct discount for quantity should pass validation&quot;)]&#10;    [InlineData(2, 0)] // 1-3 items = 0%&#10;    [InlineData(5, 10)] // 4-9 items = 10%&#10;    [InlineData(15, 20)] // 10-20 items = 20%&#10;    public void Given_CorrectDiscountForQuantity_When_Validated_Then_ShouldNotHaveError(int quantity, decimal expectedDiscount)&#10;    {&#10;        // Arrange&#10;        var saleItem = SaleItemTestData.GenerateValidSaleItem();&#10;        saleItem.Quantity = quantity;&#10;        saleItem.DiscountPercent = expectedDiscount;&#10;&#10;        // Act&#10;        var result = _validator.TestValidate(saleItem);&#10;&#10;        // Assert&#10;        result.ShouldNotHaveValidationErrorFor(si =&gt; si);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>